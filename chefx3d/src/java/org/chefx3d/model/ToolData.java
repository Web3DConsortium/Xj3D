/*****************************************************************************
 *                        Copyright Yumetech, Inc (c) 2005-2007
 *                               Java Source
 *
 * This source is licensed under the GNU LGPL v2.1
 * Please read http://www.gnu.org/copyleft/lgpl.html for more information
 *
 * This software comes with the standard NO WARRANTY disclaimer for any
 * purpose. Use it at your own risk. If there's a problem you get to fix it.
 *
 ****************************************************************************/

package org.chefx3d.model;

// External Imports
import org.w3c.dom.*;

import javax.xml.xpath.*;
import java.util.*;

// Internal Imports
import org.chefx3d.tool.Tool;
import org.chefx3d.util.DefaultErrorReporter;
import org.chefx3d.util.ErrorReporter;

/**
 * Store data generated by the tool.
 *
 * TODO: Not sure whether this should be public or not. Exporters need all of
 * this information, but its very implementation dependant.
 *
 * @author Alan Hudson
 * @version $Revision: 1.23 $
 */
public class ToolData {

    private int entityID;

    private double[] pos;

    private float[] rot;

    private Map<String, Document> properties;

    private Tool tool;

    private SegmentSequence segments;

    private int[] associatesCache;

    private boolean associatesCacheDirty;

    /** The tools associated associates */
    private List<Integer> associates;

    /** The ErrorReporter for messages */
    private ErrorReporter errorReporter;

    public ToolData(int entityID, double[] position, float[] rotation, Tool tool) {
        this(entityID, position, rotation, tool, tool.getDefaults());
    }

    public ToolData(int entityID, double[] position, float[] rotation,
            Tool tool, Map<String, Document> props) {

        this.entityID = entityID;
        pos = new double[3];
        associatesCacheDirty = true;

        pos[0] = position[0];
        pos[1] = position[1];
        pos[2] = position[2];

        rot = new float[4];

        rot[0] = rotation[0];
        rot[1] = rotation[1];
        rot[2] = rotation[2];
        rot[3] = rotation[3];

        this.tool = tool;
        associates = new ArrayList<>();

        properties = new HashMap<>(props);

        segments = new SegmentSequence(tool.getSegmentDefaults(), tool.getVertexDefaults());

        errorReporter = DefaultErrorReporter.getDefaultReporter();

    }

    /**
     * Associate an entity with this one.
     *
     * @param entity The entityID
     */
    public void addAssociation(int entity) {
        Integer entityId = entity;

        if (!associates.contains(entityId)) {
            associates.add(entityId);
            associatesCacheDirty = true;
        }
    }

    /**
     * Remove a child association.
     *
     * @param entity The child's entityID
     */
    public void removeAssociation(int entity) {
        associates.remove(new Integer(entity));
        associatesCacheDirty = true;
    }

    /**
     * Get the associates associated.
     *
     * @return The associates
     */
    public int[] getAssociates() {
        if (!associatesCacheDirty)
            return associatesCache;

        int[] ret_val = new int[associates.size()];

        int cnt = 0;

        for (Iterator<Integer> itr = associates.iterator(); itr.hasNext();) {
            ret_val[cnt++] = itr.next();
        }

        associatesCache = ret_val;
        associatesCacheDirty = false;
        return ret_val;
    }

    public void getPosition(double[] position) {
        position[0] = pos[0];
        position[1] = pos[1];
        position[2] = pos[2];
    }

    public double[] getPosition() {
        return pos;
    }

    public void getRotation(float[] rotation) {
        rotation[0] = rot[0];
        rotation[1] = rot[1];
        rotation[2] = rot[2];
        rotation[3] = rot[3];
    }

    public float[] getRotation() {
        return rot;
    }

    public void setPosition(double[] position) {
        pos[0] = position[0];
        pos[1] = position[1];
        pos[2] = position[2];
    }

    public void setRotation(float[] rotation) {
        rot[0] = rotation[0];
        rot[1] = rotation[1];
        rot[2] = rotation[2];
        rot[3] = rotation[3];
    }

    /**
     * Set the properties of a sheet.
     *
     * @param propSheet The sheet name
     * @param node The properties
     */
    public void setProperties(String propSheet, Document node) {
        properties.put(propSheet, node);
    }

    /**
     * Set all the properties sheets.
     *
     * @param props The properties
     */
    public void setProperties(Map<String, Document> props) {
        properties = new HashMap<>(props);
    }

    /**
     * Set specified properties sheets.
     *
     * @param propSheet The sheet name
     * @param propName
     * @param propValue
     */
    public void setProperties(String propSheet, String propName,
            String propValue) {

        Document doc = properties.get(propSheet);

        try {

            XPath xpath = XPathFactory.newInstance().newXPath();
            Node node = (Node) xpath.evaluate(propName, doc,
                    XPathConstants.NODE);

            if (node instanceof Text) {
                ((CharacterData) node).setData(propValue);
            } else if (node instanceof Attr) {
                ((Attr) node).setValue(propValue);
            }

        } catch (XPathExpressionException | DOMException ex) {
            errorReporter.errorReport("SetProperty Error!", ex);
        }

    }

    /**
     * Add the specified property to the document.
     *
     * @param propSheet The sheet name
     * @param propName The property name
     * @param propValue The property
     */
    public void addProperty(String propSheet, String propName, Node propValue) {

        Document doc = properties.get(propSheet);

        try {

            // find the required node in the document
            XPath xpath = XPathFactory.newInstance().newXPath();
            Node node = (Node) xpath.evaluate(propName, doc,
                    XPathConstants.NODE);

            Node importNode;

            // Import the DOM fragment into the document
            if (propValue instanceof Document) {
                importNode = doc.importNode(((Document) propValue)
                        .getDocumentElement(), true);
            } else {
                importNode = doc.importNode(propValue, true);
            }

            // now tell it to be the child of the required node
            node.appendChild(importNode);

        } catch (XPathExpressionException | DOMException ex) {
            errorReporter.errorReport("AddProperty Error!", ex);
        }

    }

    /**
     * Get the properties for a sheet.
     *
     * @param sheetName The sheet name
     * @return The properties
     */
    public Document getProperties(String sheetName) {
        return properties.get(sheetName);
    }

    /**
     * Get the properties for all sheets.
     *
     * @return The property map
     */
    public Map<String, Document> getProperties() {
        return properties;
    }

    public Tool getTool() {
        return tool;
    }

    /**
     * Get the entityID.
     *
     * @return The entityID
     */
    public int getEntityID() {
        return entityID;
    }

    /**
     * Add a segment to this tool.
     *
     * @param vertextID
     * @param pos The position of the segment
     */
    public void addSegmentVertex(int vertextID, double[] pos) {
        // TODO: This must be sequential right now. Do we want to mandate this
        // on the interface?
        segments.addVertex(vertextID, pos);
    }

    /**
     * Remove a segment vertex from this tool.
     *
     * @param vertexId
     */
    public void removeSegmentVertex(int vertexId) {
        segments.removeVertex(vertexId);
    }

    /**
     * Get the segments for this tool. If it contains no segments it will return
     * null.
     *
     * @return The segment positions
     */
    //public List<double[]> getSegments() {
    //    return (List<double[]>) segments.getVertices();
    //}

    /**
     * Register an error reporter with the command instance
     * so that any errors generated can be reported in a nice manner.
     *
     * @param reporter The new ErrorReporter to use.
     */
    public void setErrorReporter(ErrorReporter reporter) {
        errorReporter = reporter;

        if(errorReporter == null)
            errorReporter = DefaultErrorReporter.getDefaultReporter();
    }

}
